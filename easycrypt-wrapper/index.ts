import { spawn, exec } from 'child_process';
import * as fs from 'fs';
import { EasycryptError, getMostRecentGoal, processStderr } from './output-processing';
import { TERMINAL_MODE, TIMEOUT } from './config';

const file = process.argv[2];
const tempFile = `${file}.temp`;
console.log(`${file}`);
console.log(TERMINAL_MODE ? "Terminal output mode" : "File output mode");
runEasycrypt(file);

function runEasycrypt(file: string) {
	// If there are errors, remove code from where they start
	// In either case, code is only used up until the last .\n before the end
	const evaluatedLineCount = writeValidPartToTempFile(file, tempFile, []);
	if (evaluatedLineCount !== null) {
		console.log(`Running cat ${tempFile} | easycrypt`);

		exec(`cat ${tempFile} | easycrypt`, { timeout: TIMEOUT }, (err, stdout, stderr) => {
			// Primarily here for if the timeout is hit
			if (err) {
				console.log("Failed to wrap easycrypt");
				return;
			}

			// Collect and process the outputs from processing the file
			const {errors, successes} = processStderr(stderr);
			const goals = getMostRecentGoal(stdout);

			// No inner call to be made
			if (errors.length === 0) {
				if (TERMINAL_MODE) { // Reverse order of outputs depending on output format
					printSuccesses(successes);
					printGoals(goals);
					console.log(`!===NO ERRORS BY LINE ${evaluatedLineCount}===!`);
				} else {
					console.log(`!===NO ERRORS BY LINE ${evaluatedLineCount}===!`);
					printGoals(goals);
					printSuccesses(successes);
				}
			} else { // Don't output yet because inner call is async
				runEasycryptInner(tempFile, errors, successes);
			}
		});
	} else {
		console.log("No content to run easycrypt on");
	}
}

// An inner call is made only if errors are generated by the first run
function runEasycryptInner(file: string, outerErrors: EasycryptError[], outerSuccesses: string[]) {
	// If there are errors, remove code from where they start
	// In either case, code is only used up until the last .\n before the end
	const evaluatedLineCount = writeValidPartToTempFile(file, tempFile, outerErrors);
	if (evaluatedLineCount !== null) {
		console.log(`Running inner call cat ${tempFile} | easycrypt`);

		exec(`cat ${tempFile} | easycrypt`, { timeout: TIMEOUT }, (err, stdout, stderr) => {
			// Primarily here for if the timeout is hit
			if (err) {
				console.log("Failed to wrap inner easycrypt");
				return;
			}

			// Collect and process the outputs from processing the file
			const goals = getMostRecentGoal(stdout);

			if (TERMINAL_MODE) { // Reverse order of outputs depending on output format
				printSuccesses(outerSuccesses);
				printGoals(goals);
				printErrors(outerErrors);
				console.log("!===BUILD FAILED===!");
			} else {
				console.log("!===BUILD FAILED===!");
				printErrors(outerErrors);
				printGoals(goals);
				printSuccesses(outerSuccesses);
			}
		});
	} else {
		console.log("No content to run easycrypt on");
	}
}

function printErrors(errors: EasycryptError[]) {
	console.log("===Errors===");
	console.log(errors);
	console.log("======");
}

function printSuccesses(successes: string[]) {
	console.log("===Successes===");
	console.log(successes);
	console.log("======");
}

// Returns the line count of the temporary file if one is generated, otherwise null
function writeValidPartToTempFile(file: string, tempFile: string, errors: EasycryptError[]): number | null {
	let code = fs.readFileSync(file, { encoding: 'utf8' });

	// If there are errors, find the one that points to the earliest location
	const firstError = getFirstError(errors);
	if (firstError !== null) {
		// Load the file contents up to the point of the first error
		code = code
			.split('\n')
			.slice(0, firstError.endLine)
			.map((line, index) => {
				if (index < firstError.endLine) {
					return line;
				} else  {
					return line.slice(0, firstError.endColumn);
				}
			})
			.join('\n');
	}
	

	// Easycrypt's interactive mode can fail to provide helpful output if the input is cut off at the wrong point
	// So we employ a slight simplification and find the last instance of a . at the end of a line, not in a comment
	let commentLevel = 0;
	let endIndex = 0;
	for (let i = 0; i + 2 <= code.length; ++i) {
		const slice = code.slice(i, i+2);
		if (slice === '(*') {
			++commentLevel;
		} else if (slice === '*)' && commentLevel > 0) {
			--commentLevel;
		} else if (slice === '.\n' && commentLevel === 0) {
			endIndex = i+2;
		}
	}
	
	if (endIndex > 0) {
		const codeToOutput = code.slice(0, endIndex);
		fs.writeFileSync(tempFile, codeToOutput, {encoding: 'utf8'});
		return codeToOutput.split('\n').length;
	} else {
		return null;
	}
}

function getFirstError(errors: EasycryptError[]): EasycryptError | null {
	return errors.reduce((firstError: EasycryptError | null, currentError: EasycryptError) => {
		if (firstError === null) {
			return currentError;
		} else if (currentError.endLine < firstError.endLine) {
			return currentError;
		} else if (currentError.endLine === firstError.endLine && currentError.endColumn < firstError.endColumn) {
			return currentError;
		} else {
			return firstError;
		}
	}, null);
}

function printGoals(goals: string) {
	console.log("===Goals===");
	console.log(goals);
	console.log("======");
}
